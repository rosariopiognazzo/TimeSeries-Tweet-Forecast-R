---
title: "progetto-sad"
output: html_document
date: "2024-11-05"
editor_options: 
  markdown: 
    wrap: sentence
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)


library(jsonlite)#per convertire hashtags
library(readr)
library(dplyr)
library(lubridate)
library(ggplot2)

#leggiamo il dataset
Sentiment_fr_tweet_2023 <- read_csv2("C:/Users/rosar/Desktop/SAD/Sentiment_fr_tweet_2023.csv")

#Non si opera mai sul dataset originale
dataset <- Sentiment_fr_tweet_2023

#summary(dataset)
#si nota che il formato degli elementi non è corretta per la maggior parte

#aggiustiamo il formato delle variabili
dataset <- dataset %>%
  mutate(is_retweet = as.factor(is_retweet),
         is_quote_status = as.factor(is_quote_status),
         sentiment = as.factor(sentiment),
         score = as.numeric(score))
```

## Spiegazione del dataset

Questo dataset rappresenta un insieme di dati sui tweet relativi alla guerra in Ucraina, contenente oltre 112,000 osservazioni e 30 variabili.
Ogni riga rappresenta un singolo tweet con metadati associati all'utente e al contenuto.
Analizziamo innanzitutto i tipi di variabili e il loro significato:

#### Variabili utente:

-   userid: ID numerico dell'utente.

-   username: Nome utente del profilo Twitter.

-   acctdesc: Descrizione dell'account (campo testuale).

-   location: Località dell'utente (campo testuale).

-   following e followers: Numero di persone seguite e numero di follower (variabili numeriche).

-   totaltweets: Numero totale di tweet pubblicati dall'utente (variabile numerica).

-   usercreatedts: Data e ora di creazione dell'account (variabile POSIXct, che rappresenta data e ora).

#### Variabili tweet:

-   tweetid: ID numerico univoco del tweet.

-   tweetcreatedts: Data e ora di creazione del tweet (variabile POSIXct).

-   retweetcount e favorite_count: Numero di retweet e numero di “mi piace” ricevuti (variabili numeriche).

-   text: Contenuto testuale del tweet.

-   hashtags: Hashtag inclusi nel tweet (elenco testuale di hashtag e posizioni).

-   language: Lingua del tweet (campo testuale, presumibilmente codici linguistici ISO).

-   coordinates: Coordinate geografiche se disponibili (variabile logica).

-   is_retweet: Indica se il tweet è un retweet (variabile categorica con due livelli).

-   original_tweet_id, original_tweet_userid, original_tweet_username: Informazioni sui tweet originali, se il tweet corrente è un retweet o una risposta.

#### Variabili di interazione e risposta:

-   in_reply_to_status_id, in_reply_to_user_id, in_reply_to_screen_name: Informazioni sui tweet e sugli utenti a cui si risponde (variabili testuali/numeriche).

-   is_quote_status: Indica se il tweet include un altro tweet citato (variabile categorica).

-   quoted_status_id, quoted_status_userid, quoted_status_username: Informazioni sul tweet citato.

#### Variabili di sentiment:

-   sentiment: Sentimento del tweet (variabile categorica con livelli "neg", "neu", "pos").

-   score: Punteggio numerico di intensità del sentimento, da interpretare probabilmente in relazione a sentiment.

```{r}
```

### Analisi Multivariata

Per un'analisi più approfondita, esamineremo le associazioni tra alcune delle principali variabili in base ai tipi di dati:

1.  **Analisi della Popolarità dei Tweet Retweet e "Mi piace"**: Le variabili retweetcount e favorite_count sono indicative della popolarità di un tweet.
    Possiamo eseguire una correlazione per capire se il numero di retweet è associato positivamente con i "mi piace".

2.  **Effetto del numero di follower (?)**: I follower (followers) potrebbero influenzare positivamente il numero di "mi piace" e retweet ricevuti.
    Una regressione multipla potrebbe aiutarci a testare se il numero di follower e il numero di persone seguite (following) hanno un'influenza significativa sui retweet e sui "mi piace".

3.  **Analisi Temporale Volume dei tweet nel tempo**: Possiamo aggregare i tweet per intervalli temporali (es., giorno o settimana) utilizzando tweetcreatedts per osservare come varia il volume dei tweet.
    Questo ci permette di vedere i picchi di attività, possibilmente legati ad eventi rilevanti nel conflitto in Ucraina.

4.  **Evoluzione del sentimento:** Utilizzando tweetcreatedts e sentiment, possiamo calcolare il cambiamento nel sentiment (proporzione di tweet positivi, negativi e neutri) nel tempo per osservare eventuali variazioni di opinioni o emozioni in relazione agli eventi.

5.  **Analisi Geografica Distribuzione geografica dei tweet**: Se location è disponibile, una mappa di densità per rappresentare le località più attive potrebbe rivelare regioni geografiche particolarmente coinvolte.

6.  **Sentimento e localizzazione:** Possiamo anche segmentare il sentiment per località e vedere se ci sono differenze tra paesi o città, osservando, ad esempio, il sentimento medio dei tweet.

7.  **Analisi del Contenuto del Tweet Sentiment e Hashtag:** hashtags e sentiment sono utili per verificare la frequenza degli hashtag associati a ciascun sentiment.
    Potremmo scoprire se certi hashtag hanno più probabilità di essere collegati a sentimenti positivi, negativi o neutri.

8.  **Popolarità degli hashtag:** È possibile esaminare gli hashtag più usati nel dataset e valutarne l'associazione con variabili di popolarità, come retweetcount e favorite_count.

9.  **Caratteristiche degli Utenti Attivi Profilo degli utenti con più interazioni:** Potremmo filtrare per gli utenti con il maggior numero di follower o tweet, analizzando se ci sono caratteristiche comuni tra i profili più influenti.

10. **Sentiment e anzianità dell'account**: Utilizzando usercreatedts e sentiment, possiamo esplorare se esiste un'associazione tra l'anzianità dell'account e la tonalità emotiva espressa nei tweet.

Per l'analisi multivariata, ci concentreremo su alcune delle variabili quantitative e categoriche per comprendere meglio le relazioni tra di esse.
Considereremo in particolare:

-   **Followers** e **Following**: per analizzare le dinamiche di rete sociale.

-   **Totaltweets** e **Favorite_count**: per comprendere l'engagement degli utenti.

-   **Retweetcount** e **Sentiment**: per valutare come il sentiment influenzi la diffusione dei tweet.

#### Analisi quantitativa

Possiamo calcolare la matrice di correlazione tra le variabili quantitative:

-   **Followers vs. Following**: Si prevede che ci sia una correlazione positiva, indicando che gli utenti con più follower tendano a seguire più account.

-   **Totaltweets vs. Favorite_count**: Ci aspettiamo una correlazione positiva, suggerendo che più tweet vengono pubblicati, più "mi piace" ricevono.

-   **Retweetcount vs. Favorite_count**: Potrebbe emergere una correlazione, indicando che i tweet con più retweet ricevono anche più "mi piace".

```{r}


correlation_matrix <- cor(dataset[, c("following", "followers", "totaltweets", "favorite_count", "retweetcount", "score")], use = "complete.obs")

correlation_matrix
```

1.  **Following e Totaltweets**: la correlazione è positiva e moderata (0.27), indicando che gli utenti che seguono più account tendono a pubblicare più tweet.
    Questo potrebbe suggerire che gli utenti più attivi nella rete tendano a essere anche più attivi nella produzione di contenuti.

2.  **Followers e Totaltweets**: la correlazione è positiva ma debole (0.08), suggerendo che un maggior numero di follower non si traduce necessariamente in un numero significativamente più alto di tweet pubblicati.

3.  **Totaltweets e Retweetcount**: la correlazione è leggermente negativa (-0.08), il che implica che gli utenti con un numero maggiore di tweet totali tendono a ricevere un po' meno retweet, probabilmente perché non tutti i loro tweet hanno un engagement significativo.

4.  **Retweetcount e Score**: esiste una correlazione positiva e moderata (0.17), suggerendo che un punteggio di sentiment più alto potrebbe associarsi a un maggior numero di retweet.
    Questo potrebbe indicare che i tweet con un sentiment più intenso (positivo o negativo) sono più propensi a essere condivisi.

5.  **Correlazioni deboli (valori vicini a 0)**:

    -   **Followers e Favorite_count** (0.04): Non c'è una relazione forte tra il numero di follower e i "mi piace" ricevuti, il che suggerisce che la popolarità dell'utente non si traduce necessariamente in un engagement maggiore per ogni tweet.

    -   **Score e altre variabili**: A parte con `retweetcount`, `score` ha correlazioni molto deboli con le altre variabili, suggerendo che il sentiment non è un fattore rilevante per le altre misure di engagement come i "mi piace" e il numero di follower.

#### Interpretazione Generale

La matrice delle correlazioni rivela che:

-   **Il numero di following** e **la produzione di contenuti** sono leggermente correlati, indicando che gli utenti che seguono di più tendono a essere più attivi.

-   **Il sentiment del tweet** influisce sul numero di retweet, suggerendo che i tweet con un sentiment più forte tendono a diffondersi maggiormente.

-   L’engagement non sembra direttamente influenzato dal numero di follower, il che potrebbe indicare che la viralità di un contenuto dipende più dal contenuto stesso che dalla popolarità dell’utente.

#### **Analisi delle Variabili Categoriali (qualitative)**

Si potrebbe esplorare come il sentiment dei tweet (positivo, neutro, negativo) influisce sul numero di retweet e "mi piace".
Utilizzando boxplot o grafici a barre, possiamo confrontare le medie di `favorite_count` e `retweetcount` per ogni livello di sentiment.

```{r}
ggplot(dataset, aes(x=sentiment, y=log(favorite_count))) +
  geom_boxplot(aes(fill = sentiment)) +
  labs(title="Distribuzione dei Favorite Count per Sentiment") +
  theme_minimal()
```

```{r}
ggplot(dataset, aes(x=sentiment, y=log(retweetcount))) +
  geom_boxplot(aes(fill = sentiment)) +
  labs(title="Distribuzione dei Retweet Count per Sentiment") +
  theme_minimal()
```

```{r}
# 1. Pre-processamento: Convertire il timestamp in una colonna temporale e aggiungere un intervallo temporale (es. settimana)
# Assicuriamoci che tweetcreatedts sia in formato Date-Time e che sentiment sia un fattore o stringa
dataset$tweetcreatedts <- as.POSIXct(dataset$tweetcreatedts, format="%Y-%m-%d %H:%M:%S")
dataset$sentiment <- as.factor(dataset$sentiment)

# Raggruppa i dati per settimana
data_weekly <- dataset %>%
  mutate(week = floor_date(tweetcreatedts, unit = "week")) %>%
  group_by(week, sentiment) %>%
  summarise(count = n()) %>%
  ungroup()

# 2. Calcolo della proporzione di sentimenti per settimana
# Calcoliamo il totale dei tweet per ogni settimana per ottenere le proporzioni di ciascun sentimento
data_weekly <- data_weekly %>%
  group_by(week) %>%
  mutate(total_tweets = sum(count)) %>%
  ungroup() %>%
  mutate(proportion = count / total_tweets)

# 3. Visualizzazione dell'evoluzione del sentiment nel tempo
ggplot(data_weekly, aes(x = week, y = proportion, color = sentiment, group = sentiment)) +
  geom_line(size = 1) +
  geom_point(size = 2) +
  labs(title = "Evoluzione del Sentiment nel Tempo",
       x = "Settimana",
       y = "Proporzione di Sentiment",
       color = "Sentiment") +
  theme_minimal()
```

#### **Analisi della Rete Sociale**

Utilizzando variabili come `followers`, `following`, e `is_retweet`, possiamo costruire un grafico della rete sociale per visualizzare le connessioni tra gli utenti

#### Modelli Regressione

Si potrebbe anche considerare di costruire modelli predittivi (ad es. regressione) per stimare il numero di retweet o di "mi piace" basandosi su altre variabili, come il sentiment e il numero di follower.

```{r}
model <- lm(retweetcount ~ followers + following + sentiment, data=dataset)
summary(model)
```

### Interpretazione dei Coefficienti

1.  **(Intercept)**: L'intercetta è 204.8, indicando che, in media, quando tutte le variabili predittive sono a zero, la risposta attesa è di circa 204.8 unità.
    Questo valore è il punto di partenza per l'interpretazione delle altre variabili.

2.  **followers**: Il coefficiente di `followers` è -2.768e-05.
    Questo suggerisce che per ogni aumento di un follower, la variabile di risposta diminuisce di 0.00002768 unità.
    Anche se è statisticamente significativo (p\<0.001p \< 0.001p\<0.001), l'effetto è molto piccolo, quindi il numero di follower non sembra avere un impatto rilevante.

3.  **following**: Il coefficiente di `following` è -0.007723, indicando che ogni aumento di un account seguito (following) è associato a una riduzione di circa 0.0077 unità nella risposta.
    Questo effetto è statisticamente significativo (p\<0.001p \< 0.001p\<0.001) e suggerisce che un maggior numero di following può influire leggermente negativamente sulla variabile di risposta.

4.  **sentimentneu**: Il coefficiente di `sentimentneu` è 23.72.
    Questo implica che, rispetto al sentiment negativo (presumibilmente la categoria di riferimento), un tweet con sentiment neutro aumenta la variabile di risposta di circa 23.72 unità, un effetto positivo e statisticamente significativo (p\<0.001p \< 0.001p\<0.001).

5.  **sentimentpos**: Il coefficiente di `sentimentpos` è -22.41.
    Questo significa che un sentiment positivo, rispetto a quello negativo, diminuisce la variabile di risposta di circa 22.41 unità.
    Anche questo effetto è statisticamente significativo (p\<0.001p \< 0.001p\<0.001), ma va in direzione opposta rispetto al sentiment neutro.

### Valutazione del Modello

-   **Residual standard error (RSE)**: L'errore standard residuo è 389.8, suggerendo che la variabilità residua dei dati è alta.
    Questo valore indica che il modello non cattura molta della variabilità nei dati.

-   **Multiple R-squared**: 0.00535, indica che solo lo 0.535% della variabilità nella variabile di risposta è spiegata dal modello, un valore molto basso.
    Ciò significa che le variabili predittive scelte spiegano pochissimo dell’engagement o della metrica che si sta tentando di prevedere.

-   **Adjusted R-squared**: 0.005315, simile al valore di R2R\^2R2 non aggiustato, conferma che l’aggiunta di queste variabili nel modello non porta a miglioramenti significativi nella spiegazione della variabilità.

-   **F-statistic**: L'F-statistic è 151.9 con un valore p molto basso (\<2.2e−16\< 2.2e-16\<2.2e−16), indicando che il modello nel suo complesso è statisticamente significativo, quindi almeno una delle variabili predittive ha un effetto sulla variabile di risposta.

### Conclusioni

Anche se il modello è statisticamente significativo, la sua capacità di spiegare la variabilità della risposta è molto limitata (R2R\^2R2 basso).
Questo suggerisce che le variabili `followers`, `following`, e `sentiment` non sono sufficienti a prevedere con precisione l’engagement o l’output di interesse.
Probabilmente sono necessarie ulteriori variabili predittive, come caratteristiche del tweet o informazioni contestuali aggiuntive, per costruire un modello più accurato.

### Considerazioni Finali e Approccio di Analisi

Per implementare questa analisi, potremmo utilizzare tecniche di regressione, analisi delle componenti principali (PCA) per le variabili numeriche e categoriali, e visualizzazioni come heatmap temporali e geografiche.

### Utilizzo di modelli non lineari o più complessi

Vista la complessità del dataset e la bassa capacità esplicativa del modello lineare semplice, utilizzare modelli di regressione più avanzati potrebbe aiutare a migliorare la capacità predittiva e a ridurre l’impatto di osservazioni anomale o di alta dimensionalità.
Ecco come alcune tecniche specifiche potrebbero essere applicate in questo contesto:

#### 1. **Regressione Lineare Robusta (con stimatore di Huber)**

-   **Quando è utile**: Lo stimatore di Huber è particolarmente adatto quando ci sono outlier nella variabile di risposta che potrebbero distorcere i risultati della regressione ordinaria.
    La regressione robusta con Huber penalizza meno i valori estremi, riducendo il loro impatto sul modello.

-   **Applicazione al dataset**: In questo dataset, la presenza di alcune osservazioni con `retweetcount` o `favorite_count` estremamente alti potrebbe influenzare le stime dei coefficienti.
    Utilizzare lo stimatore di Huber potrebbe mitigare l’influenza degli outlier, permettendo una stima più stabile dei parametri.

#### 2. **Regressione Penalizzata (Lasso, Ridge, Elastic-Net)**

-   **Quando è utile**: La regressione penalizzata è particolarmente efficace in presenza di molte variabili predittive, ridondanze o alta correlazione tra i predittori (multicollinearità).
    Inoltre, le tecniche di penalizzazione aiutano a migliorare la selezione delle variabili, mantenendo solo quelle con un impatto significativo.

-   **Tipi di penalizzazione**:

    -   **Lasso** (Least Absolute Shrinkage and Selection Operator) forza alcuni coefficienti a zero, eliminando di fatto le variabili meno rilevanti.
        Questo è utile quando si sospetta che solo alcune delle variabili abbiano un vero effetto sulla risposta.

    -   **Ridge** invece riduce l’ampiezza dei coefficienti senza annullarne nessuno, migliorando la stabilità del modello e aiutando con la multicollinearità, mantenendo però tutte le variabili nel modello.

    -   **Elastic-Net** combina le proprietà di Lasso e Ridge e può essere utile in dataset come questo, dove vi sono molte variabili potenzialmente ridondanti.
        Elastic-Net è particolarmente adatto quando si hanno variabili fortemente correlate, poiché riesce a gestirle in modo efficace selezionando gruppi di variabili correlate.

-   **Applicazione al dataset**: Dato che variabili come `following`, `followers`, `totaltweets`, e misure di sentiment possono avere effetti complessi e non immediatamente evidenti, Lasso o Elastic-Net potrebbero essere utili per capire quali variabili effettivamente contribuiscono all’engagement.
    Elastic-Net potrebbe aiutare a selezionare variabili, considerando che ci sono legami non trascurabili tra variabili come `following` e `totaltweets`.

#### 3. **Modelli Non Lineari**

-   **Quando è utile**: I modelli non lineari possono essere preziosi quando ci sono relazioni complesse tra le variabili che non possono essere catturate da una semplice relazione lineare.
    Ad esempio, l’effetto del numero di follower o following potrebbe non essere lineare; potrebbe esserci un effetto soglia oltre il quale l’engagement aumenta o diminuisce in modo significativo.

-   **Possibili approcci**:

    -   **Regressione polinomiale**: Può essere usata per modellare relazioni curvilinee.
        Ad esempio, un termine quadratico per `followers` potrebbe catturare un eventuale aumento o riduzione dell’engagement a livelli estremamente alti o bassi.

    -   **Modelli ad albero (o modelli ensemble)** come Gradient Boosting o Random Forests, possono modellare relazioni non lineari e interazioni complesse tra le variabili, senza dover specificare una forma funzionale a priori.

-   **Applicazione al dataset**: Dato che l'engagement sui social può spesso dipendere da soglie o comportamenti non lineari, modelli come Random Forests o Gradient Boosting potrebbero captare queste dinamiche complesse e migliorare la previsione dell’engagement.

#### 4. **Considerazioni sulle Interazioni tra le Variabili**

-   Potrebbe essere utile includere interazioni tra variabili.
    Ad esempio, l’effetto combinato di `followers` e `sentiment` potrebbe avere un impatto differente sul `retweetcount` rispetto all’effetto di ognuna di queste variabili da sola.

-   Le interazioni potrebbero essere testate prima con una **regressione lineare con interazioni**, oppure lasciate a modelli come gli **alberi decisionali** che le catturano automaticamente.

#### Sintesi e Proposta di Modellazione

Iniziare con **Elastic-Net** potrebbe essere una buona strategia, poiché selezionerà le variabili rilevanti e gestirà la multicollinearità.
Successivamente, si potrebbe:

-   Aggiungere **modelli non lineari** per esplorare le relazioni complesse.

-   Utilizzare **Random Forests** o **Gradient Boosting** per approfondire le interazioni non lineari.

-   Valutare infine l’applicazione dello stimatore di **Huber** se si riscontrano ancora forti effetti distorsivi degli outlier.

Questo approccio graduale dovrebbe permettere di costruire un modello di engagement più accurato e interpretabile, catturando le dinamiche complesse del dataset.

### Analisi di rete sociale

#### 1. **Preparazione del Dataset per l'Analisi di Rete**

-   **Definisci i nodi e gli archi**: In una rete sociale, gli utenti rappresentano i nodi e le interazioni (come retweet, menzioni o risposte) sono gli archi.

-   **Estrarre le interazioni**: Le colonne `userid`, `original_tweet_userid`, `in_reply_to_user_id`, e `quoted_status_userid` contengono informazioni rilevanti per costruire le connessioni tra utenti.

#### 2. **Costruzione della Rete**

-   Usa un pacchetto come **igraph** o **network** per creare una rete da queste relazioni:

    -   **`retweet` e `quote`**: Creare un arco dal nodo dell’utente al nodo del tweet originale.

    -   **`mentions` e `replies`**: Se l’utente menziona un altro utente o risponde a un suo tweet, crea un arco dal nodo che risponde o menziona verso il nodo dell’utente menzionato.

#### 3. **Analisi della Rete Sociale**

Una volta costruita la rete, è possibile analizzarla usando alcune tecniche di base per descrivere la struttura e le dinamiche della rete:

-   **Metriche di base**:

    -   **Grado di connessione (Degree)**: Calcola il numero di connessioni (entranti o uscenti) di ciascun nodo, per vedere quali utenti sono più influenti o più attivi.

    -   **Centralità di intermediazione (Betweenness Centrality)**: Indica quanto un nodo si trova su percorsi più brevi tra altri nodi, utile per identificare utenti che agiscono come "ponti" tra diverse parti della rete.

    -   **Centralità di vicinanza (Closeness Centrality)**: Misura la distanza media tra un nodo e tutti gli altri nella rete.
        Utile per capire quali utenti sono "vicini" a molti altri.

-   **Comunità e Cluster**:

    -   **Rilevazione di comunità**: Usa metodi come **Louvain** o **Girvan-Newman** per individuare gruppi di utenti che interagiscono frequentemente tra loro.
        Questo può essere utile per vedere se esistono gruppi di supporto o cluster di opinioni.

-   **Visualizzazione della rete**:

    -   Visualizza la rete con pacchetti come **ggraph** o **visNetwork**, usando colori e dimensioni dei nodi per rappresentare centralità e connessioni.

#### 4. **Tecniche Avanzate**

-   **Analisi di Assortatività**: Misura quanto i nodi con proprietà simili (ad es. grado o sentiment) tendono a connettersi tra di loro.
    Questa tecnica può rivelare se utenti con sentiment simile formano cluster.

-   **Analisi di omofilia**: Verifica se c’è una tendenza degli utenti a connettersi con altri con caratteristiche simili, come il numero di follower o la posizione.

-   **Analisi Temporale**: Se vuoi studiare come cambia la rete nel tempo, suddividi i dati in periodi di tempo (es. settimane o mesi) e costruisci una serie di reti per ogni intervallo, confrontando le metriche nel tempo.

```{}
library(igraph)
library(ggraph)
library(tidyverse)

# Costruzione della rete
# Considerando `userid` e `original_tweet_userid` come esempio
edges <- dataset %>% 
  filter(original_tweet_userid != "0.0") %>% # Rimuove valori non validi
  select(userid, original_tweet_userid) %>% 
  rename(from = userid, to = original_tweet_userid)

# Crea il grafo
network <- graph_from_data_frame(d = edges, directed = TRUE)

# Calcolo delle metriche
degree <- degree(network, mode = "all")
betweenness <- betweenness(network, directed = TRUE)
closeness <- closeness(network, mode = "all")

# Rilevazione di comunità
community <- cluster_louvain(network)

# Aggiungi attributi al grafo
V(network)$degree <- degree
V(network)$betweenness <- betweenness
V(network)$closeness <- closeness
V(network)$community <- membership(community)

# Visualizzazione della rete
ggraph(network, layout = "fr") +
  geom_edge_link(aes(alpha = ..index..), show.legend = FALSE) +
  geom_node_point(aes(size = degree, color = as.factor(community)), show.legend = TRUE) +
  theme_void()
```
