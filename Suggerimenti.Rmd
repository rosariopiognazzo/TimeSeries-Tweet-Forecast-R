---
title: "Suggerimenti"
author: "Rosario Pio Gnazzo"
date: "2025-01-19"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(readr)
library(dplyr)
library(tidyr)
library(tibble)
library(ggplot2)
library(lubridate)
library(reshape2)
library(scales)
```

Per quanto riguarda l'analisi generale del dataset, cercando un modo intelligente per identificare gli utenti influenti, ho estratto questo dataset dove ogni riga è un **utente,** mentre ogni colonna è una informazione globale per quel determinato utente. Ad esempio, utente **X** ha fatto 5 tweet nei 7 giorni di cui noi teniamo i dati, dati questi 5 tweet ho estratto informazioni come: numero di retweet, risposte, citazioni totali ricevuti, andamento del numero di following, followers ecc.

Il codice per generare questo nuovo dataset è questo:\

```{r}
#carica il dataset
sentiment <- read_csv2("C:/Users/Utente/Documenti/Sentiment_fr_tweet_2023.csv")

dataset <- sentiment
dataset <- dataset %>%
  mutate(userid = as.character(userid),
         username = as.character(username),
         acctdesc = as.character(acctdesc),
         location = as.character(location),
         following = as.numeric(following),
         followers = as.numeric(followers),
         totaltweets = as.numeric(totaltweets),
         tweetid = as.character(tweetid),
         retweetcount = as.numeric(retweetcount),
         favorite_count = as.numeric(favorite_count),
         text = as.character(text),
         language = as.character(language),
         favorite_count = as.numeric(favorite_count),
         
         is_retweet = as.factor(is_retweet),
         original_tweet_id = format(as.numeric(original_tweet_id), 
                                    scientific = FALSE),
         original_tweet_userid = format(as.numeric(original_tweet_userid), 
                                    scientific = FALSE),
         original_tweet_username = as.character(original_tweet_username),
         
         in_reply_to_status_id = format(as.numeric(in_reply_to_status_id), 
                                    scientific = FALSE),
         in_reply_to_user_id = format(as.numeric(in_reply_to_user_id), 
                                    scientific = FALSE),
         in_reply_to_screen_name = as.character(in_reply_to_screen_name),
           
         is_quote_status = as.factor(is_quote_status),
         quoted_status_id = format(as.numeric(quoted_status_id), 
                                    scientific = FALSE),
         quoted_status_userid = format(as.numeric(quoted_status_userid), 
                                    scientific = FALSE),
         quoted_status_username = as.character(quoted_status_username),
         
         sentiment = as.factor(sentiment),
         score = as.numeric(score)
         )

# Partizionamento varie tipologie di tweet
dfPartizionati <- dataset %>%
  mutate(
    Tipo_Tweet = case_when(
      # Retweet
      is_retweet == TRUE ~ "Retweet",
      # Risposte
      in_reply_to_status_id != "                  0" & is_retweet == FALSE ~ "Risposta",
      # Citazioni
      is_quote_status == TRUE & is_retweet == FALSE & in_reply_to_status_id == "                  0" ~ "Citazione",
      # Tweet Normali
      TRUE ~ "Normale"
    )
  )

# Dataset globale per utente
#
# Aggregazione per utente
dfUtenti <- dfPartizionati %>%
  group_by(userid, username) %>%
  summarise(
    # Conteggio tweet per categoria
    Totale_Tweet = n(),
    Totale_Retweet = sum(Tipo_Tweet == "Retweet"),
    Totale_Risposte = sum(Tipo_Tweet == "Risposta"),
    Totale_Citazioni = sum(Tipo_Tweet == "Citazione"),
    Totale_Normali = sum(Tipo_Tweet == "Normale"),
    
    # Andamenti temporali
    Following_Min = min(following, na.rm = TRUE),
    Following_Max = max(following, na.rm = TRUE),
    Followers_Min = min(followers, na.rm = TRUE),
    Followers_Max = max(followers, na.rm = TRUE),
    Totaltweets_Min = min(totaltweets, na.rm = TRUE),
    Totaltweets_Max = max(totaltweets, na.rm = TRUE),
    
    # Sentiment
    Sentiment_Pos = mean(score[sentiment == "pos"], na.rm = TRUE),
    Sentiment_Neu = mean(score[sentiment == "neu"], na.rm = TRUE),
    Sentiment_Neg = mean(score[sentiment == "neg"], na.rm = TRUE),
    
    # Intervallo temporale dei dati
    Data_Inizio = min(tweetcreatedts, na.rm = TRUE),
    Data_Fine = max(tweetcreatedts, na.rm = TRUE),
    
    # Interazioni calcolate dai tipi di tweet
    Totale_Interazioni = Totale_Risposte + Totale_Citazioni,
    
    # Coinvolgimento
    Media_Retweet = mean(retweetcount, na.rm = TRUE),
    Media_Like = mean(favorite_count, na.rm = TRUE),
    Totale_Retweet = sum(retweetcount, na.rm = TRUE),
    Totale_Like = sum(favorite_count, na.rm = TRUE),
    
    # Rapporto attività/account
    Giorni_Attivi = as.numeric(difftime(max(tweetcreatedts, na.rm = TRUE), min(tweetcreatedts, na.rm = TRUE), units = "days")),
    Tweet_Giornalieri_Medi = Totale_Tweet / Giorni_Attivi,
    Rapporto_Follower_Following = mean(followers / following, na.rm = TRUE),
    
    # Distribuzione temporale delle attività
    Orario_Preferito = names(sort(table(tweetcreatedts), decreasing = TRUE)[1])
  ) %>%
  ungroup()

# Calcolo delle metriche di attività e influenza e classificazione
dfUtenti <- dfUtenti %>%
  mutate(
    # Metriche di Attività
    Interazioni_Totali = Totale_Retweet + Totale_Risposte + Totale_Citazioni,
    Coerenza_Temporale = Giorni_Attivi / Totale_Tweet,
    
    # Metriche di Influenza
    Engagement_Totale = Totale_Retweet + Totale_Like,
    Engagement_Relativo = Engagement_Totale / Followers_Max,
    Media_Retweet_Per_Tweet = Totale_Retweet / Totale_Tweet,
    Media_Like_Per_Tweet = Totale_Like / Totale_Tweet,
    
    # Classificazione per Attività
    Classe_Attivita = case_when(
      Totale_Tweet >= quantile(Totale_Tweet, 0.75) ~ "Alta",
      Totale_Tweet >= quantile(Totale_Tweet, 0.50) ~ "Moderata",
      TRUE ~ "Bassa"
    ),
    
    # Classificazione per Influenza
    Classe_Influenza = case_when(
      Engagement_Relativo >= quantile(Engagement_Relativo, 0.75, na.rm = TRUE) ~ "Alta",
      Engagement_Relativo >= quantile(Engagement_Relativo, 0.50, na.rm = TRUE) ~ "Moderata",
      TRUE ~ "Bassa"
    )
  )
```

Controlla questo dataset, non tutte le informazioni (colonne) magari sono utilissime oppure potrebbero avere degli errori per come sono calcolate. Dopo averlo controllato, fai delle analisi su questo dataset seguendo quello che hai iniziato a fare sul dataset normale. Così in questa prima parte abbiamo sia l'analisi dal **punto di vista dei tweet**, **sia dal punto di vista degli utenti** e stiamo apposto.

Idee di analisi da fare sul dataset (Ispirate da chat), non vanno fatte tutte, magari scegli solo quelle migliori e più utili.

### **1. Distribuzioni di Base**

   **Distribuzione dei Tweet per Tipo**:

    -   Grafico a barre: distribuzione di `Totale_Retweet`, `Totale_Risposte`, `Totale_Citazioni`, `Totale_Normali`.
```{r}
    dfTipoTweet <- dfPartizionati %>%
  group_by(Tipo_Tweet) %>%
  summarise(Totale = n())

ggplot(dfTipoTweet, aes(x = Tipo_Tweet, y = Totale, fill = Tipo_Tweet)) +
  geom_bar(stat = "identity") +
  labs(title = "Distribuzione dei Tweet per Tipo", x = "Tipo di Tweet", y = "Totale") +
  theme_minimal()


    #Boxplot per confrontare le medie tra le categorie di tweet.
ggplot(dfPartizionati, aes(x = Tipo_Tweet, y = retweetcount, fill = Tipo_Tweet)) +
  geom_boxplot() +
  labs(title = "Distribuzione dei Retweet per Tipo di Tweet", x = "Tipo di Tweet", y = "Numero di Retweet") +
  theme_minimal()



  # **Distribuzione delle Metriche di Engagement**:

    #   Istogramma di `Totale_Like` e `Totale_Retweet`.
    ggplot(dfUtenti, aes(x = Totale_Like)) +
  geom_histogram(binwidth = 50, fill = "blue", color = "white") +
  labs(title = "Distribuzione dei Like Totali", x = "Totale Like", y = "Frequenza") +
  theme_minimal()

#Istogramma di `retweet``.
ggplot(dfUtenti, aes(x = Totale_Retweet)) +
  geom_histogram(binwidth = 10, fill = "red", color = "white") +
  labs(title = "Distribuzione dei Retweet Totali", x = "Totale Retweet", y = "Frequenza") +
  theme_minimal()


     # Boxplot di `Media_Like_Per_Tweet` e `Media_Retweet_Per_Tweet`.
    
ggplot(dfUtenti, aes(x = Classe_Influenza, y = Media_Like_Per_Tweet, fill = Classe_Influenza)) +
  geom_boxplot() +
  labs(title = "Media Like per Tweet per Classe di Influenza", x = "Classe di Influenza", y = "Media Like per Tweet") +
  theme_minimal()


  # **Distribuzione dei Followers e Following**:

   #  Istogramma e boxplot di `Followers_Max` e `Following_Max`.
ggplot(dfUtenti, aes(x = Followers_Max)) +
  geom_histogram(binwidth = 100, fill = "green", color = "white") +
  labs(title = "Distribuzione del Massimo Numero di Followers", x = "Massimo Followers", y = "Frequenza") +
  theme_minimal()


    #-   Scatter plot per il rapporto `Rapporto_Follower_Following`.
ggplot(dfUtenti, aes(x = Following_Max, y = Followers_Max)) +
  geom_point(color = "purple") +
  labs(title = "Rapporto Followers-Following", x = "Massimo Following", y = "Massimo Followers") +
  theme_minimal()
```

```{r}
### **2. Analisi Temporali**

 # **Evoluzione dell'Attività degli Utenti**
# Line plot di Totaltweets_Max nel tempo
ggplot(dfUtenti, aes(x = Data_Fine, y = Totaltweets_Max)) +
  geom_line(color = "blue", size = 1) +
  labs(
    title = "Evoluzione dell'Attività degli Utenti nel Tempo",
    x = "Data Fine",
    y = "Totale Tweet Massimi"
  ) +
  theme_minimal()

# Heatmap della distribuzione dei tweet per orario o giorno della settimana
# Prima prepariamo i dati per la heatmap
dfHeatmap <- dataset %>%
  mutate(
    Giorno_Settimana = wday(tweetcreatedts, label = TRUE),
    Ora = hour(tweetcreatedts)
  ) %>%
  group_by(Giorno_Settimana, Ora) %>%
  summarise(Totale_Tweet = n(), .groups = "drop")

# Heatmap
ggplot(dfHeatmap, aes(x = Ora, y = Giorno_Settimana, fill = Totale_Tweet)) +
  geom_tile(color = "white") +
  scale_fill_gradient(low = "lightblue", high = "blue") +
  labs(
    title = "Distribuzione dei Tweet per Orario e Giorno della Settimana",
    x = "Ora del Giorno",
    y = "Giorno della Settimana",
    fill = "Totale Tweet"
  ) +
  theme_minimal()

# **Durata dell'Attività**
# Istogramma di Giorni_Attivi
ggplot(dfUtenti, aes(x = Giorni_Attivi)) +
  geom_histogram(bins = 30, fill = "darkgreen", color = "white", alpha = 0.8) +
  labs(
    title = "Distribuzione della Durata dell'Attività degli Utenti",
    x = "Giorni Attivi",
    y = "Conteggio Utenti"
  ) +
  theme_minimal()

# Boxplot per confrontare Giorni_Attivi tra le classi di attività
ggplot(dfUtenti, aes(x = Classe_Attivita, y = Giorni_Attivi, fill = Classe_Attivita)) +
  geom_boxplot(alpha = 0.7) +
  scale_fill_brewer(palette = "Set2") +
  labs(
    title = "Confronto della Durata dell'Attività tra Classi di Attività",
    x = "Classe di Attività",
    y = "Giorni Attivi"
  ) +
  theme_minimal()
  
```


```{r}
### **3. Analisi di Coinvolgimento**
# **Relazione tra Engagement e Follower**
# Scatter plot di Engagement_Totale vs. Followers_Max
ggplot(dfUtenti, aes(x = Followers_Max, y = Engagement_Totale)) +
  geom_point(color = "blue", alpha = 0.6) +
  labs(
    title = "Relazione tra Engagement Totale e Numero di Follower",
    x = "Numero Massimo di Follower",
    y = "Engagement Totale"
  ) +
  theme_minimal()

# Scatter plot di Engagement_Relativo vs. Followers_Max con fit lineare
ggplot(dfUtenti, aes(x = Followers_Max, y = Engagement_Relativo)) +
  geom_point(color = "darkorange", alpha = 0.6) +
  geom_smooth(method = "lm", color = "red", se = FALSE) +
  labs(
    title = "Relazione tra Engagement Relativo e Numero di Follower",
    x = "Numero Massimo di Follower",
    y = "Engagement Relativo"
  ) +
  theme_minimal()

# **Engagement Relativo tra le Classi di Attività**
# Boxplot di Engagement_Relativo per Classe_Attivita
ggplot(dfUtenti, aes(x = Classe_Attivita, y = Engagement_Relativo, fill = Classe_Attivita)) +
  geom_boxplot(alpha = 0.7) +
  scale_fill_brewer(palette = "Pastel1") +
  labs(
    title = "Engagement Relativo tra le Classi di Attività",
    x = "Classe di Attività",
    y = "Engagement Relativo"
  ) +
  theme_minimal()

# **Engagement Medio per Tipo di Utente**
# Preparazione dei dati per il Barplot
dfEngagementMedio <- dfUtenti %>%
  group_by(Classe_Influenza) %>%
  summarise(
    Media_Like_Per_Tweet = mean(Media_Like_Per_Tweet, na.rm = TRUE),
    Media_Retweet_Per_Tweet = mean(Media_Retweet_Per_Tweet, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  melt(id.vars = "Classe_Influenza", variable.name = "Tipo_Engagement", value.name = "Media_Engagement")

# Barplot delle medie di Media_Like_Per_Tweet e Media_Retweet_Per_Tweet per Classe_Influenza
ggplot(dfEngagementMedio, aes(x = Classe_Influenza, y = Media_Engagement, fill = Tipo_Engagement)) +
  geom_bar(stat = "identity", position = "dodge", alpha = 0.8) +
  scale_fill_brewer(palette = "Set2") +
  labs(
    title = "Engagement Medio per Tipo di Utente",
    x = "Classe di Influenza",
    y = "Media Engagement",
    fill = "Tipo di Engagement"
  ) +
  theme_minimal()
```


```{r}
### **4. Classificazione degli Utenti**

# **Grafico a torta o barre per la distribuzione delle Classi**
# Calcolo della distribuzione delle Classi di Attività
dfClasseAttivita <- dfUtenti %>%
  count(Classe_Attivita) %>%
  mutate(Percentuale = n / sum(n) * 100)

# Grafico a torta per Classe_Attivita
ggplot(dfClasseAttivita, aes(x = "", y = Percentuale, fill = Classe_Attivita)) +
  geom_bar(stat = "identity", width = 1, color = "white") +
  coord_polar("y", start = 0) +
  scale_fill_brewer(palette = "Set3") +
  labs(
    title = "Distribuzione delle Classi di Attività",
    x = NULL, 
    y = NULL,
    fill = "Classe di Attività"
  ) +
  theme_minimal()

# Calcolo della distribuzione delle Classi di Influenza
dfClasseInfluenza <- dfUtenti %>%
  count(Classe_Influenza) %>%
  mutate(Percentuale = n / sum(n) * 100)

# Grafico a barre per Classe_Influenza
ggplot(dfClasseInfluenza, aes(x = Classe_Influenza, y = Percentuale, fill = Classe_Influenza)) +
  geom_bar(stat = "identity", alpha = 0.8) +
  scale_fill_brewer(palette = "Pastel2") +
  labs(
    title = "Distribuzione delle Classi di Influenza",
    x = "Classe di Influenza",
    y = "Percentuale",
    fill = "Classe di Influenza"
  ) +
  theme_minimal()

# **Heatmap incrociata tra Classe_Attivita e Classe_Influenza**
# Tabella di contingenza
dfContingenza <- table(dfUtenti$Classe_Attivita, dfUtenti$Classe_Influenza)

# Conversione in formato long per ggplot
dfContingenzaLong <- as.data.frame(as.table(dfContingenza))

# Heatmap
ggplot(dfContingenzaLong, aes(Var1, Var2, fill = Freq)) +
  geom_tile(color = "white") +
  scale_fill_gradient(low = "lightblue", high = "darkblue") +
  labs(
    title = "Heatmap tra Classi di Attività e Influenza",
    x = "Classe di Attività",
    y = "Classe di Influenza",
    fill = "Frequenza"
  ) +
  theme_minimal()
```


```{r}
### **5. Analisi di Sentiment**

# **Sentiment Medio per Utente**

# Boxplot di Sentiment_Pos, Sentiment_Neu, e Sentiment_Neg per le Classi di Influenza
dfUtenti <- dfUtenti %>%
  mutate(Data_Inizio = as.Date(Data_Inizio, format = "%Y-%m-%d"))

dfSentiment <- dfUtenti %>%
  select(Classe_Influenza, Sentiment_Pos, Sentiment_Neu, Sentiment_Neg) %>%
  pivot_longer(
    cols = starts_with("Sentiment"),
    names_to = "Tipo_Sentiment",
    values_to = "Valore_Sentiment"
  )

ggplot(dfSentiment, aes(x = Classe_Influenza, y = Valore_Sentiment, fill = Tipo_Sentiment)) +
  geom_boxplot(alpha = 0.7, outlier.color = "red", outlier.shape = 16) +
  scale_fill_brewer(palette = "Set2") +
  labs(
    title = "Sentiment Medio per Classe di Influenza",
    x = "Classe di Influenza",
    y = "Valore Sentiment",
    fill = "Tipo di Sentiment"
  ) +
  theme_minimal()

# Heatmap dell'intensità del sentiment (positivi vs. negativi) nel tempo
dfSentimentTime <- dfUtenti %>%
  group_by(Data_Inizio) %>%
  summarise(
    Sentiment_Pos_Medio = mean(Sentiment_Pos, na.rm = TRUE),
    Sentiment_Neg_Medio = mean(Sentiment_Neg, na.rm = TRUE)
  ) %>%
  pivot_longer(
    cols = c(Sentiment_Pos_Medio, Sentiment_Neg_Medio),
    names_to = "Tipo_Sentiment",
    values_to = "Intensita_Sentiment"
  )

ggplot(dfSentimentTime, aes(x = Data_Inizio, y = Tipo_Sentiment, fill = Intensita_Sentiment)) +
  geom_tile(color = "white") +
  scale_fill_gradient(low = "lightblue", high = "darkblue") +
  labs(
    title = "Heatmap dell'Intensità del Sentiment nel Tempo",
    x = "Data",
    y = "Tipo di Sentiment",
    fill = "Intensità"
  ) +
  theme_minimal() +
  scale_x_date(labels = date_format("%b %Y"))

# **Relazione tra Sentiment e Coinvolgimento**

# Scatter plot di Sentiment_Pos vs. Engagement_Totale
ggplot(dfUtenti, aes(x = Sentiment_Pos, y = Engagement_Totale)) +
  geom_point(alpha = 0.7, color = "darkgreen") +
  geom_smooth(method = "lm", color = "red", se = FALSE) +
  labs(
    title = "Relazione tra Sentiment Positivo e Coinvolgimento Totale",
    x = "Sentiment Positivo Medio",
    y = "Engagement Totale"
  ) +
  theme_minimal()

# Scatter plot di Sentiment_Neg vs. Engagement_Totale
ggplot(dfUtenti, aes(x = Sentiment_Neg, y = Engagement_Totale)) +
  geom_point(alpha = 0.7, color = "darkred") +
  geom_smooth(method = "lm", color = "blue", se = FALSE) +
  labs(
    title = "Relazione tra Sentiment Negativo e Coinvolgimento Totale",
    x = "Sentiment Negativo Medio",
    y = "Engagement Totale"
  ) +
  theme_minimal()
```



### **6. Analisi delle Interazioni**

-   **Diversità delle Interazioni**:

    -   Barplot di `Diversita_Interazioni` per le diverse classi di influenza.

    -   Scatter plot di `Diversita_Interazioni` vs. `Totale_Interazioni`.

-   **Analisi della Rete Sociale**:

    -   Grafico network (opzionale): visualizzazione degli utenti con alti valori di `Diversita_Interazioni`.

### **7. Confronto tra Classi**

-   **Confronto delle Metriche Chiave**:

    -   Boxplot o violin plot per `Totale_Tweet`, `Engagement_Totale`, `Followers_Max`, ecc., suddivisi per `Classe_Attivita` e `Classe_Influenza`.

-   **Attività Relativa e Tweet Giornalieri**:

    -   Scatter plot di `Tweet_Giornalieri_Medi` vs. `Classe_Attivita`.

### **8. Analisi Avanzate (se applicabile)**

-   **Correlazioni**:

    -   Matrice di correlazione per le variabili quantitative, come `Totale_Tweet`, `Engagement_Totale`, `Followers_Max`, ecc.

    -   Heatmap delle correlazioni.

-   **Clusterizzazione degli Utenti**:

    -   Algoritmi di clustering (es. K-means) per raggruppare utenti con caratteristiche simili (es. engagement, attività, followers).
