---
title: "Analisi_Utenti"
author: "Rosario Pio Gnazzo"
date: "2025-01-24"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(readr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(gridExtra)
library(tibble)
```

```{r}
Sentiment_fr_tweet_2023 <- read_csv2("C:/Users/rosar/Desktop/UNISA/Magistrale - Informatica/SAD/Sentiment_fr_tweet_2023.csv")

#laptop
#Sentiment_fr_tweet_2023 <- read_csv2("C:/Users/rosar/Desktop/SAD/Sentiment_fr_tweet_2023.csv")

dataset <- Sentiment_fr_tweet_2023

dataset <- dataset %>%
  mutate(userid = as.character(userid),
         username = as.character(username),
         acctdesc = as.character(acctdesc),
         location = as.character(location),
         following = as.numeric(following),
         followers = as.numeric(followers),
         totaltweets = as.numeric(totaltweets),
         tweetid = as.character(tweetid),
         retweetcount = as.numeric(retweetcount),
         favorite_count = as.numeric(favorite_count),
         text = as.character(text),
         language = as.character(language),
         favorite_count = as.numeric(favorite_count),
         
         is_retweet = as.factor(is_retweet),
         original_tweet_id = format(as.numeric(original_tweet_id), 
                                    scientific = FALSE),
         original_tweet_userid = format(as.numeric(original_tweet_userid), 
                                    scientific = FALSE),
         original_tweet_username = as.character(original_tweet_username),
         
         in_reply_to_status_id = format(as.numeric(in_reply_to_status_id), 
                                    scientific = FALSE),
         in_reply_to_user_id = format(as.numeric(in_reply_to_user_id), 
                                    scientific = FALSE),
         in_reply_to_screen_name = as.character(in_reply_to_screen_name),
           
         is_quote_status = as.factor(is_quote_status),
         quoted_status_id = format(as.numeric(quoted_status_id), 
                                    scientific = FALSE),
         quoted_status_userid = format(as.numeric(quoted_status_userid), 
                                    scientific = FALSE),
         quoted_status_username = as.character(quoted_status_username),
         
         sentiment = as.factor(sentiment),
         score = as.numeric(score)
         )
```

```{r}
# Etichettatura dei post nel dataset
dataset <- dataset %>%
  mutate(
    # Determinazione del tipo di tweet
    Tipo_Tweet = case_when(
      is_retweet == TRUE ~ "Retweet",
      in_reply_to_status_id != "                  0" & is_retweet == FALSE ~ "Risposta",
      is_quote_status == TRUE & is_retweet == FALSE & in_reply_to_status_id == "                  0" ~ "Citazione",
      TRUE ~ "Normale"
    )
  )

# Estrazione degli ID univoci da tutti i campi rilevanti
tutti_gli_id <- dataset %>%
  select(userid, original_tweet_userid, in_reply_to_user_id, quoted_status_userid) %>%
  pivot_longer(cols = everything(), values_to = "id") %>%
  filter(!is.na(id)) %>%
  distinct(id)

# Unire con il dataset originale per calcolare le metriche per utente
risultati_utenti <- dataset %>%
  group_by(userid) %>%
  summarise(
    Totale_Tweet = n(),
    Totale_Retweet = sum(Tipo_Tweet == "Retweet"),
    Totale_Risposte = sum(Tipo_Tweet == "Risposta"),
    Totale_Citazioni = sum(Tipo_Tweet == "Citazione"),
    Totale_TweetNormali = sum(Tipo_Tweet == "Normale"),
    
    TweetNormali_Pos = sum(Tipo_Tweet == "Normale" & sentiment == "pos"),
    TweetNormali_Neu = sum(Tipo_Tweet == "Normale" & sentiment == "neu"),
    TweetNormali_Neg = sum(Tipo_Tweet == "Normale" & sentiment == "neg"),
    
    Retweet_Pos = sum(Tipo_Tweet == "Retweet" & sentiment == "pos"),
    Retweet_Neu = sum(Tipo_Tweet == "Retweet" & sentiment == "neu"),
    Retweet_Neg = sum(Tipo_Tweet == "Retweet" & sentiment == "neg"),
    
    Replay_Pos = sum(Tipo_Tweet == "Risposta" & sentiment == "pos"),
    Replay_Neu = sum(Tipo_Tweet == "Risposta" & sentiment == "neu"),
    Replay_Neg = sum(Tipo_Tweet == "Risposta" & sentiment == "neg"),
    
    Quotes_Pos = sum(Tipo_Tweet == "Citazione" & sentiment == "pos"),
    Quotes_Neu = sum(Tipo_Tweet == "Citazione" & sentiment == "neu"),
    Quotes_Neg = sum(Tipo_Tweet == "Citazione" & sentiment == "neg"),
    
    # Calcolo delle medie globali per ciascun sentiment
    GlobalMean_Pos = ifelse(sum(sentiment == "pos") > 0, mean(score[sentiment == "pos"], na.rm = TRUE), 0),
    GlobalMean_Neu = ifelse(sum(sentiment == "neu") > 0, mean(score[sentiment == "neu"], na.rm = TRUE), 0),
    GlobalMean_Neg = ifelse(sum(sentiment == "neg") > 0, mean(score[sentiment == "neg"], na.rm = TRUE), 0),
    
    # Calcolo delle medie per i tweet normali per ciascun sentiment
    Mean_Pos_Norm = ifelse(sum(Tipo_Tweet == "Normale" & sentiment == "pos") > 0,
                           mean(score[Tipo_Tweet == "Normale" & sentiment == "pos"], na.rm = TRUE), 0),
    Mean_Neu_Norm = ifelse(sum(Tipo_Tweet == "Normale" & sentiment == "neu") > 0,
                           mean(score[Tipo_Tweet == "Normale" & sentiment == "neu"], na.rm = TRUE), 0),
    Mean_Neg_Norm = ifelse(sum(Tipo_Tweet == "Normale" & sentiment == "neg") > 0,
                           mean(score[Tipo_Tweet == "Normale" & sentiment == "neg"], na.rm = TRUE), 0),
    
    Totale_Interazioni = Totale_Risposte + Totale_Citazioni,
    Media_Retweet = mean(retweetcount, na.rm = TRUE),
    Media_Like = mean(favorite_count, na.rm = TRUE),
    Totale_Retweet = sum(retweetcount, na.rm = TRUE),
    Totale_Like = sum(favorite_count, na.rm = TRUE),
    Followers_Min = min(followers, na.rm = TRUE),
    Followers_Max = max(followers, na.rm = TRUE),
    Rapporto_Follower_Following = mean(followers / following, na.rm = TRUE)
  )

```

```{r}
# Aggiunta di nuove metriche per l'etichettatura
risultati_utenti <- risultati_utenti %>%
  mutate(
    # Metriche di Attività
    Interazioni_Totali = Totale_Retweet + Totale_Risposte + Totale_Citazioni,
    
    # Metriche di Influenza
    Engagement_Totale = Totale_Retweet + Totale_Like,
    Engagement_Relativo = Engagement_Totale / Followers_Max,
    Media_Retweet_Per_Tweet = Totale_Retweet / Totale_Tweet,
    Media_Like_Per_Tweet = Totale_Like / Totale_Tweet,
    
    # Etichettatura per attività
    Attività_Utente = case_when(
      Totale_Tweet > quantile(Totale_Tweet, 0.75, na.rm = TRUE) |
      Interazioni_Totali > quantile(Interazioni_Totali, 0.75, na.rm = TRUE) ~ "Molto Attivo",
      Totale_Tweet > quantile(Totale_Tweet, 0.25, na.rm = TRUE) |
      Interazioni_Totali > quantile(Interazioni_Totali, 0.25, na.rm = TRUE) ~ "Moderatamente Attivo",
      TRUE ~ "Poco Attivo"
    ),
    
    # Etichettatura per influenza
    Influenza_Utente = case_when(
      Followers_Max > quantile(Followers_Max, 0.75, na.rm = TRUE) |
      Engagement_Totale > quantile(Engagement_Totale, 0.75, na.rm = TRUE) |
      Engagement_Relativo > quantile(Engagement_Relativo, 0.75, na.rm = TRUE) ~ "Influente",
      Followers_Max > quantile(Followers_Max, 0.25, na.rm = TRUE) |
      Engagement_Totale > quantile(Engagement_Totale, 0.25, na.rm = TRUE) |
      Engagement_Relativo > quantile(Engagement_Relativo, 0.25, na.rm = TRUE) ~ "Moderatamente Influente",
      TRUE ~ "Poco Influente"
    ),
    
    # Calcolo dei punteggi ponderati (sostituendo NaN con 0)
    SentimentPOS_Ponderato = ifelse(is.nan(Mean_Pos_Norm * 0.5 + GlobalMean_Pos * 0.2), 0, Mean_Pos_Norm * 0.5 + GlobalMean_Pos * 0.2),
    SentimentNEG_Ponderato = ifelse(is.nan(Mean_Neg_Norm * 0.5 + GlobalMean_Neg * 0.2), 0, Mean_Neg_Norm * 0.5 + GlobalMean_Neg * 0.2),
    SentimentNEU_Ponderato = ifelse(is.nan(Mean_Neu_Norm * 0.5 + GlobalMean_Neu * 0.2), 0, Mean_Neu_Norm * 0.5 + GlobalMean_Neu * 0.2),
    
    # Etichettatura basata sul punteggio più alto
    Tipologia_Sentiment = case_when(
      SentimentPOS_Ponderato > SentimentNEG_Ponderato & SentimentPOS_Ponderato > SentimentNEU_Ponderato ~ "Positivo",
      SentimentNEG_Ponderato > SentimentPOS_Ponderato & SentimentNEG_Ponderato > SentimentNEU_Ponderato ~ "Negativo",
      TRUE ~ "Neutrale"
    )
    
  )


risultati_utenti <- risultati_utenti %>% mutate(
  userid = format(as.numeric(userid), 
                                    scientific = FALSE)
)
```

### 1. **Analisi della distribuzione dei sottogruppi**

**Descrizione:**

-   Esamina la distribuzione dei sottogruppi creati (es. attività, influenza, tipologia di sentiment) per ottenere una panoramica di come gli utenti si comportano e quale ruolo giocano all'interno del contesto analizzato.

-   Calcola la percentuale di utenti per ogni categoria e confronta la loro composizione.

**Importanza:**

-   Aiuta a capire il panorama generale della comunità analizzata.

-   Permette di identificare quali gruppi sono predominanti (es. utenti influenti o utenti passivi) e quindi di orientare le azioni strategiche.

```{r}
# Distribuzione dei sottogruppi basata su metriche chiave
distribuzione_sottogruppi <- risultati_utenti %>%
  summarise(
    Attivi = sum(Totale_Tweet > median(Totale_Tweet, na.rm = TRUE)),
    Passivi = sum(Totale_Tweet <= median(Totale_Tweet, na.rm = TRUE)),
    Influencers = sum(Engagement_Totale > median(Engagement_Totale, na.rm = TRUE)),
    Non_Influencers = sum(Engagement_Totale <= median(Engagement_Totale, na.rm = TRUE))
  )

# Grafico a barre per la distribuzione
distribuzione_grafico <- distribuzione_sottogruppi %>%
  pivot_longer(cols = everything(), names_to = "Gruppo", values_to = "Conteggio") %>%
  ggplot(aes(x = Gruppo, y = Conteggio, fill = Gruppo)) +
  geom_bar(stat = "identity") +
  labs(title = "Distribuzione dei Sottogruppi", x = "Sottogruppo", y = "Conteggio") +
  theme_minimal()

print(distribuzione_grafico)

## plot2
distribuzione_sottogruppi <- risultati_utenti %>%
  summarise(
    Molto_Attivi = sum(Attività_Utente=="Molto Attivo"),
    Moderato_Attivo = sum(Attività_Utente=="Moderatamente Attivo"),
    Poco_Attivo = sum(Attività_Utente=="Poco Attivo"),
    
    Influente = sum(Influenza_Utente=="Influente"),
    Moderato_Influente = sum(Influenza_Utente=="Moderatamente Influente"),
    Poco_Influente = sum(Influenza_Utente=="Poco Influente"),
    
    Negativi = sum(Tipologia_Sentiment=="Negativo"),
    Neutrali = sum(Tipologia_Sentiment=="Neutrale"),
    Positivi = sum(Tipologia_Sentiment=="Positivo")
  )

# Grafico a barre per la distribuzione
distribuzione_grafico <- distribuzione_sottogruppi %>%
  pivot_longer(cols = everything(), names_to = "Gruppo", values_to = "Conteggio") %>%
  ggplot(aes(x = Gruppo, y = Conteggio, fill = Gruppo)) +
  geom_bar(stat = "identity") +
  labs(title = "Distribuzione dei Sottogruppi", x = "Sottogruppo", y = "Conteggio") +
  theme_minimal()

print(distribuzione_grafico)
```

### 2. **Analisi della relazione tra attività e influenza**

**Descrizione:**

-   Valuta come l’attività degli utenti (es. numero di tweet, risposte, citazioni) si correla con le metriche di influenza (es. numero di follower, engagement relativo).

-   Usa tecniche come la correlazione o modelli di regressione per identificare relazioni.

**Importanza:**

-   Utile per identificare se l'influenza è una funzione diretta dell'attività o se alcuni utenti ottengono un’influenza sproporzionata rispetto al loro livello di partecipazione.

-   Questo insight può aiutare a distinguere tra "leader di pensiero" e "utenti iperattivi" ma meno influenti.

```{r}
# Scatterplot per attività vs influenza
attivita_vs_influenza <- risultati_utenti %>%
  ggplot(aes(x = Totale_Tweet, y = Engagement_Totale, color = Engagement_Relativo)) +
  geom_point(alpha = 0.6) +
  labs(
    title = "Relazione tra Attività e Influenza",
    x = "Totale Tweet",
    y = "Engagement Totale",
    color = "Engagement Relativo"
  ) +
  theme_minimal()

print(attivita_vs_influenza)

# Calcolo della correlazione
correlazione <- cor(risultati_utenti$Totale_Tweet, risultati_utenti$Engagement_Totale, use = "complete.obs")

print(paste("Correlazione tra Attività e Influenza:", correlazione))
```

### 3. **Analisi del sentiment rispetto al tipo di attività**

**Descrizione:**

-   Confronta come il sentiment prevalente (negativo, positivo, neutrale) varia in base al tipo di tweet (normali, retweet, risposte, citazioni).

-   Identifica pattern come "gli utenti tendono a condividere più contenuti negativi nelle risposte rispetto ai tweet normali".

**Importanza:**

-   Permette di comprendere il tono della comunicazione nei diversi contesti.

-   Aiuta a identificare se determinate categorie di attività (es. risposte) amplificano determinati sentimenti, che può essere utile per la moderazione o per progettare interventi mirati.

```{r}
# Distribuzione del sentiment per tipo di attività
sentiment_attivita <- risultati_utenti %>%
  select(TweetNormali_Pos, TweetNormali_Neu, TweetNormali_Neg,
         Retweet_Pos, Retweet_Neu, Retweet_Neg,
         Replay_Pos, Replay_Neu, Replay_Neg,
         Quotes_Pos, Quotes_Neu, Quotes_Neg) %>%
  summarise_all(sum, na.rm = TRUE) %>%
  pivot_longer(cols = everything(), names_to = "Tipo_Sentiment", values_to = "Conteggio") %>%
  mutate(Tipo_Tweet = case_when(
    grepl("Normali", Tipo_Sentiment) ~ "Normale",
    grepl("Retweet", Tipo_Sentiment) ~ "Retweet",
    grepl("Replay", Tipo_Sentiment) ~ "Risposta",
    TRUE ~ "Citazione"
  )) %>%
  mutate(Sentiment = case_when(
    grepl("Pos", Tipo_Sentiment) ~ "Positivo",
    grepl("Neu", Tipo_Sentiment) ~ "Neutrale",
    TRUE ~ "Negativo"
  ))

# Grafico stacked bar
sentiment_attivita_grafico <- sentiment_attivita %>%
  ggplot(aes(x = Tipo_Tweet, y = Conteggio, fill = Sentiment)) +
  geom_bar(stat = "identity", position = "fill") +
  labs(
    title = "Distribuzione del Sentiment per Tipo di Attività",
    x = "Tipo di Attività",
    y = "Proporzione",
    fill = "Sentiment"
  ) +
  theme_minimal()

print(sentiment_attivita_grafico)
```

### 4. **Analisi dell'interazione tra sottogruppi**

**Descrizione:**

-   Studia come gli utenti di un sottogruppo interagiscono con quelli di altri gruppi.

-   Ad esempio, verifica se gli utenti influenti ricevono più risposte dagli utenti meno attivi o se gli utenti positivi interagiscono più frequentemente con utenti neutrali o negativi.

**Importanza:**

-   Aiuta a comprendere le dinamiche della rete sociale e il flusso di informazioni.

-   Può rivelare cluster di interazioni significativi (es. polarizzazione) o punti di connessione tra diversi gruppi.

```{r}
## migliorare !! 
# Creazione di metriche di interazione
interazione_sottogruppi <- risultati_utenti %>%
  group_by(Tipologia_Sentiment) %>%
  summarise(
    Risposte_Medie = mean(Totale_Risposte, na.rm = TRUE),
    Citazioni_Medie = mean(Totale_Citazioni, na.rm = TRUE),
    Engagement_Medio = mean(Engagement_Totale, na.rm = TRUE)
  )

# Visualizzazione tramite grafico
interazione_grafico <- interazione_sottogruppi %>%
  pivot_longer(cols = c(Risposte_Medie, Citazioni_Medie, Engagement_Medio), names_to = "Metrica", values_to = "Valore") %>%
  ggplot(aes(x = Tipologia_Sentiment, y = Valore, fill = Metrica)) +
  geom_bar(stat = "identity", position = "fill") +
  labs(
    title = "Interazioni tra Sottogruppi",
    x = "Tipologia Sentiment",
    y = "Valore Medio",
    fill = "Metrica"
  ) +
  theme_minimal()

print(interazione_grafico)
```

### 6. **Clusterizzazione e analisi dei gruppi di utenti**

**Descrizione:**

-   Utilizza tecniche di clustering (es. K-means, DBSCAN) per identificare gruppi di utenti basati su metriche come attività, influenza e sentiment.

-   Analizza le caratteristiche distintive di ciascun cluster.

**Importanza:**

-   Rende possibile scoprire pattern latenti non immediatamente visibili con le analisi descrittive.

-   Utile per personalizzare le strategie di engagement per ciascun cluster.

#### PCA

```{r}
library(cluster)
library(factoextra)

# PCA
pca_input <- risultati_utenti %>%
  select(-c(userid, Attività_Utente, Influenza_Utente, Tipologia_Sentiment)) %>%
  filter_all(all_vars(!is.infinite(.))) %>%
  na.omit()

pca <- prcomp(pca_input, scale. = TRUE)

# Scree plot
fviz_eig(pca, addlabels = TRUE, ylim = c(0, 100), 
         main = "Varianza spiegata dalle componenti principali")
#Ogni barra rappresenta la percentuale di varianza spiegata da una componente.

pca_10 <- pca$x[, 1:10]
#pca_10$rotation <- pca$rotation[, 1:10]
```

```{r}
# Visualizzazione PCA
fviz_pca_ind(pca, geom.ind = "point", col.ind = "cos2") +
  labs(title = "PCA: Proiezione dei Gruppi di Utenti")
#Questo grafico ti permette di vedere come i tuoi dati sono distribuiti lungo le prime due componenti principali.
```

```{r}
fviz_pca_var(pca, 
             col.var = "contrib", # Colore basato sul contributo alla componente
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             axes = c(1,2))+
  labs(title = "PCA: Contributo alle prime due componenti")
#Questo grafico mostra quali variabili influenzano maggiormente ciascuna componente
```

```{r}
fviz_contrib(pca, choice = "var", axes = 1)+
  labs(title = "Contributo delle variabili alla PCA 1")
fviz_contrib(pca, choice = "var", axes = 2)+
  labs(title = "Contributo delle variabili alla PCA 2")
fviz_contrib(pca, choice = "var", axes = 3)+
  labs(title = "Contributo delle variabili alla PCA 3")
fviz_contrib(pca, choice = "var", axes = 4)+
  labs(title = "Contributo delle variabili alla PCA 4")
fviz_contrib(pca, choice = "var", axes = 5)+
  labs(title = "Contributo delle variabili alla PCA 5")
fviz_contrib(pca, choice = "var", axes = 6)+
  labs(title = "Contributo delle variabili alla PCA 6")
fviz_contrib(pca, choice = "var", axes = 7)+
  labs(title = "Contributo delle variabili alla PCA 7")
fviz_contrib(pca, choice = "var", axes = 8)+
  labs(title = "Contributo delle variabili alla PCA 8")
fviz_contrib(pca, choice = "var", axes = 9)+
  labs(title = "Contributo delle variabili alla PCA 9")
fviz_contrib(pca, choice = "var", axes = 10)+
  labs(title = "Contributo delle variabili alla PCA 10")
```

#### KMeans

##### Scelta ottimale del k:

```{r}
# K-means
set.seed(123)
## Metodi per trovare k ottimo: ####
#1: Calcola la WSS per vari valori di k: GOMITO
wss <- sapply(1:10, function(k) {
  kmeans(pca_10, centers = k, nstart = 10)$tot.withinss
})

# Crea il grafico del metodo del gomito
plot(1:10, wss, type = "b", pch = 19, frame = FALSE,
     xlab = "Numero di cluster", 
     ylab = "WSS",
     main = "Metodo del Gomito")+
  abline(v = 2, lty = 2, col="darkred")+
  abline(v = 3, lty = 2, col="darkblue")
```

```{r}
#2: Calcola l'indice di SILHUETTE per diversi valori di k
silhouette_fun <- function(k){
  km <- kmeans(pca_10, centers = k, nstart = 10)
  sil <- silhouette(km$cluster, dist(pca_10))
  mean(sil[,3])
}

k_values <- 2:10
silhouette_scores <- sapply(k_values,silhouette_fun)


# Visualizza il grafico
plot(2:10, silhouette_scores[1:9], type = "b", pch = 19, frame = FALSE,
     xlab = "Numero di cluster", ylab = "Punteggio medio di silhouette",
     main = "Indice di silhouette")+
  abline(v = 2, lty = 2, col="darkred")
```

```{r}
#Calinski-Harabasz sui dati normali
Xt <- pca_input
set.seed(22)

kmeans_k2 <- kmeans(Xt, centers = 2)
kmeans_k3 <- kmeans(Xt, centers = 3)

#centroidi dei cluster
centroidi_k2 <- kmeans_k2$centers
centroidi_k3 <- kmeans_k3$centers

# calcolo WCSS
wcss_k2 <- sum(kmeans_k2$withinss)
wcss_k3 <- sum(kmeans_k3$withinss)

# Calcolo BCSS
centr_glob <- colMeans(Xt)
cat("Centroide Globale ", centr_glob, "\n")

bcss_k2 <- 0
for (i in 1:length(unique(kmeans_k2$cluster))) {
  cluster_points_k2 <- Xt[kmeans_k2$cluster == i, , drop = FALSE]
  cluster_size <- nrow(cluster_points_k2)
  if (cluster_size > 0) {  # Evita cluster vuoti
    cluster_centroid <- centroidi_k2[i, ]
    bcss_k2 <- bcss_k2 + cluster_size * sum((cluster_centroid - centr_glob)^2)
  }
}

bcss_k3 <- 0
for (i in 1:length(unique(kmeans_k3$cluster))) {
  cluster_points_k3 <- Xt[kmeans_k3$cluster == i, , drop = FALSE]
  cluster_size <- nrow(cluster_points_k3)
  if (cluster_size > 0) {  # Evita cluster vuoti
    cluster_centroid <- centroidi_k3[i, ]
    bcss_k3 <- bcss_k3 + cluster_size * sum((cluster_centroid - centr_glob)^2)
  }
}


n <- nrow(Xt)

k_k2 <- length(unique(kmeans_k2$cluster))
CH_k2 <- (bcss_k2 / (k_k2 - 1)) / (wcss_k2 / (n - k_k2))

k_k3 <- length(unique(kmeans_k3$cluster))
CH_k3 <- (bcss_k3 / (k_k3 - 1)) / (wcss_k3 / (n - k_k3))

```

```{r}
# Risultati 
cat("WCSS per k=2: ", wcss_k2, "\n")
cat("WCSS per k=3: ", wcss_k3, "\n")

cat("BCSS per k=2: ", bcss_k2, "\n")
cat("BCSS per k=3: ", bcss_k3, "\n")

cat("Indice Calinski-Harabasz per k=2: ", CH_k2, "\n")
cat("Indice Calinski-Harabasz per k=3: ", CH_k3, "\n")

```

```{r}
#Calinski-Harabasz sulla PCA
Xt <- pca_10
set.seed(22)

kmeans_k2 <- kmeans(Xt, centers = 2)
kmeans_k3 <- kmeans(Xt, centers = 3)

#centroidi dei cluster
centroidi_k2 <- kmeans_k2$centers
centroidi_k3 <- kmeans_k3$centers

# calcolo WCSS
wcss_k2 <- sum(kmeans_k2$withinss)
wcss_k3 <- sum(kmeans_k3$withinss)

# Calcolo BCSS
centr_glob <- colMeans(Xt)
cat("Centroide Globale ", centr_glob, "\n")

bcss_k2 <- 0
for (i in 1:length(unique(kmeans_k2$cluster))) {
  cluster_points_k2 <- Xt[kmeans_k2$cluster == i, , drop = FALSE]
  cluster_size <- nrow(cluster_points_k2)
  if (cluster_size > 0) {  # Evita cluster vuoti
    cluster_centroid <- centroidi_k2[i, ]
    bcss_k2 <- bcss_k2 + cluster_size * sum((cluster_centroid - centr_glob)^2)
  }
}

bcss_k3 <- 0
for (i in 1:length(unique(kmeans_k3$cluster))) {
  cluster_points_k3 <- Xt[kmeans_k3$cluster == i, , drop = FALSE]
  cluster_size <- nrow(cluster_points_k3)
  if (cluster_size > 0) {  # Evita cluster vuoti
    cluster_centroid <- centroidi_k3[i, ]
    bcss_k3 <- bcss_k3 + cluster_size * sum((cluster_centroid - centr_glob)^2)
  }
}


n <- nrow(Xt)

k_k2 <- length(unique(kmeans_k2$cluster))
CH_k2 <- (bcss_k2 / (k_k2 - 1)) / (wcss_k2 / (n - k_k2))

k_k3 <- length(unique(kmeans_k3$cluster))
CH_k3 <- (bcss_k3 / (k_k3 - 1)) / (wcss_k3 / (n - k_k3))

```

```{r}
# Risultati 
cat("WCSS per k=2: ", wcss_k2, "\n")
cat("WCSS per k=3: ", wcss_k3, "\n")

cat("BCSS per k=2: ", bcss_k2, "\n")
cat("BCSS per k=3: ", bcss_k3, "\n")

cat("Indice Calinski-Harabasz per k=2: ", CH_k2, "\n")
cat("Indice Calinski-Harabasz per k=3: ", CH_k3, "\n")

```

##### Estrazione Cluster da PCA + confronto con label ricavati in precedenza

```{r}
library(mclust)

X <- risultati_utenti %>%
filter_all(all_vars(!is.infinite(.))) %>%
  na.omit()

kmeans_res3 <- kmeans(pca_10, centers = 3)
X$Cluster_Kmeans <- kmeans_res3$cluster

# Biplot colorato per i cluster K-means
fviz_pca_ind(pca, 
             geom = "point",
             col.ind = as.factor(X$Cluster_Kmeans),  # Colori per cluster
             palette = "jco",
             title = "PCA colorata per Cluster K-means")
```

```{r}
# Tabella di contingenza per Tipologia di sentiment
table(X$Tipologia_Sentiment, X$Cluster_Kmeans)

ari <- adjustedRandIndex(X$Tipologia_Sentiment, X$Cluster_Kmeans)
cat("Adjusted Rand Index (ARI): ", ari)

# Biplot colorato per la categoria originale
fviz_pca_ind(pca, 
             geom = "point",
             col.ind = X$Tipologia_Sentiment,  # Colori per categoria
             palette = "jco",
             title = "PCA colorata per Categoria Originale")
```

```{r}
# Tabella di contingenza per Attività dell'utente
table(X$Attività_Utente, X$Cluster_Kmeans)

ari <- adjustedRandIndex(X$Attività_Utente, X$Cluster_Kmeans)
cat("Adjusted Rand Index (ARI): ", ari)

# Biplot colorato per la categoria originale
fviz_pca_ind(pca, 
             geom = "point",
             col.ind = X$Attività_Utente,  # Colori per categoria
             palette = "jco",
             title = "PCA colorata per Categoria Originale")
```

```{r}
# Tabella di contingenza per Influenza dell'Utente
table(X$Influenza_Utente, X$Cluster_Kmeans)

ari <- adjustedRandIndex(X$Influenza_Utente, X$Cluster_Kmeans)
cat("Adjusted Rand Index (ARI): ", ari)

# Biplot colorato per la categoria originale
fviz_pca_ind(pca, 
             geom = "point",
             col.ind = X$Influenza_Utente,  # Colori per categoria
             palette = "jco",
             title = "PCA colorata per Categoria Originale")
```

##### Estrazione Cluster da PCA + confronto con label ricavati in precedenza

```{r}
set.seed(123)  # Assicura la riproducibilità
kmeans_result <- kmeans(pca_input, centers = 3)  # Sostituisci k con il numero ottimale

X$cluster_2 <- kmeans_result$cluster
```

```{r}
# Tabella di contingenza per Tipologia di sentiment
t = table(X$Tipologia_Sentiment, X$cluster_2)
t

ari <- adjustedRandIndex(X$Tipologia_Sentiment, X$cluster_2)
cat("\nAdjusted Rand Index (ARI): ", ari, "\n")

purity <- function(table) {
  sum(apply(table, 2, max)) / sum(table)
}

p <- purity(t)
cat("Purezza dei cluster rispetto alle originali: ", p, "\n")
```

```{r}
# Tabella di contingenza per Attività dell'utente
t = table(X$Attività_Utente, X$cluster_2)
t

ari <- adjustedRandIndex(X$Attività_Utente, X$cluster_2)
cat("\nAdjusted Rand Index (ARI): ", ari, "\n")

purity <- function(table) {
  sum(apply(table, 2, max)) / sum(table)
}

p <- purity(t)
cat("Purezza dei cluster rispetto alle originali: ", p, "\n")
```

```{r}
t = table(X$Influenza_Utente, X$cluster_2)
t

ari <- adjustedRandIndex(X$Influenza_Utente, X$cluster_2)
cat("\nAdjusted Rand Index (ARI): ", ari, "\n")

purity <- function(table) {
  sum(apply(table, 2, max)) / sum(table)
}

p <- purity(t)
cat("Purezza dei cluster rispetto alle originali: ", p, "\n")
```

### 7. **Analisi del rapporto sentiment-engagement**

**Descrizione:**

-   Esamina come il sentiment degli utenti influisce sull’engagement ricevuto (es. numero di retweet, like, risposte).

-   Confronta l’engagement medio per tweet positivi, negativi e neutri.

**Importanza:**

-   Permette di capire quali tipi di sentiment suscitano maggiore interesse o reazioni nella community.

-   Aiuta a progettare strategie per aumentare l’engagement.

```{r}
sentiment_engagement <- risultati_utenti %>%
  group_by(Tipologia_Sentiment) %>%
  summarise(
    Engagement_Medio = mean(Engagement_Totale, na.rm = TRUE),
    Engagement_Relativo_Medio = mean(Engagement_Relativo, na.rm = TRUE)
  )

# Grafico
sentiment_engagement_grafico <- sentiment_engagement %>%
  pivot_longer(cols = c(Engagement_Medio, Engagement_Relativo_Medio), names_to = "Metrica", values_to = "Valore") %>%
  ggplot(aes(x = Tipologia_Sentiment, y = Valore, fill = Metrica)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(
    title = "Rapporto Sentiment-Engagement",
    x = "Tipologia Sentiment",
    y = "Engagement Medio",
    fill = "Metrica"
  ) +
  theme_minimal()

print(sentiment_engagement_grafico)
```

### 9. **Confronto tra utenti attivi e passivi**

**Descrizione:**

-   Analizza le differenze tra gli utenti con elevata attività e quelli con bassa attività in termini di sentiment, engagement e influenza.

**Importanza:**

-   Identifica potenziali influencer dormienti o utenti che generano un alto impatto con pochi contributi.

-   Aiuta a ottimizzare le strategie di coinvolgimento mirato.

```{r}

# Confronto metriche
confronto_metriche <- risultati_utenti %>%
  group_by(Attività_Utente) %>%
  summarise(
    Sentiment_Pos_Medio = mean(SentimentPOS_Ponderato, na.rm = TRUE),
    Sentiment_Neu_Medio = mean(SentimentNEU_Ponderato, na.rm = TRUE),
    Sentiment_Neg_Medio = mean(SentimentNEG_Ponderato, na.rm = TRUE)
  )

# Grafico
confronto_metriche_grafico <- confronto_metriche %>%
  pivot_longer(cols = -Attività_Utente, names_to = "Metrica", values_to = "Valore") %>%
  ggplot(aes(x = Attività_Utente, y = Valore, fill = Metrica)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(
    title = "Confronto tra Utenti Attivi e Passivi",
    x = "Tipologia Utente",
    y = "Valore Medio",
    fill = "Metrica"
  ) +
  theme_minimal()

print(confronto_metriche_grafico)
```
