---
title: "Network_analysis"
author: "Rosario Pio Gnazzo"
date: "2025-01-16"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, 
                      message=FALSE, 
                      warning=FALSE, 
                      fig.align='center', fig.width = 10)
options(xts_check_TZ = FALSE)
library(readr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(highfrequency)
library(xts)
library(forecast)
library(lubridate)
library(gridExtra)
library(urca)
library(tibble)

library(igraph)
#detach(package:igraph)
library(network)
library(intergraph)
library(GGally)
library(purrr)
```

```{r}
Sentiment_fr_tweet_2023 <- read_csv2("C:/Users/rosar/Desktop/UNISA/Magistrale - Informatica/SAD/Sentiment_fr_tweet_2023.csv")

#laptop
#Sentiment_fr_tweet_2023 <- read_csv2("C:/Users/rosar/Desktop/SAD/Sentiment_fr_tweet_2023.csv")

dataset <- Sentiment_fr_tweet_2023

dataset <- dataset %>%
  mutate(userid = as.character(userid),
         username = as.character(username),
         acctdesc = as.character(acctdesc),
         location = as.character(location),
         following = as.numeric(following),
         followers = as.numeric(followers),
         totaltweets = as.numeric(totaltweets),
         tweetid = as.character(tweetid),
         retweetcount = as.numeric(retweetcount),
         favorite_count = as.numeric(favorite_count),
         text = as.character(text),
         language = as.character(language),
         favorite_count = as.numeric(favorite_count),
         
         is_retweet = as.factor(is_retweet),
         original_tweet_id = format(as.numeric(original_tweet_id), 
                                    scientific = FALSE),
         original_tweet_userid = format(as.numeric(original_tweet_userid), 
                                    scientific = FALSE),
         original_tweet_username = as.character(original_tweet_username),
         
         in_reply_to_status_id = format(as.numeric(in_reply_to_status_id), 
                                    scientific = FALSE),
         in_reply_to_user_id = format(as.numeric(in_reply_to_user_id), 
                                    scientific = FALSE),
         in_reply_to_screen_name = as.character(in_reply_to_screen_name),
           
         is_quote_status = as.factor(is_quote_status),
         quoted_status_id = format(as.numeric(quoted_status_id), 
                                    scientific = FALSE),
         quoted_status_userid = format(as.numeric(quoted_status_userid), 
                                    scientific = FALSE),
         quoted_status_username = as.character(quoted_status_username),
         
         sentiment = as.factor(sentiment),
         score = as.numeric(score)
         )
```

```{r}
df <- dataset %>%
  mutate(
    # Creiamo una colonna con una lista di ID (userid + original_tweet_userid) per ogni riga
    utenti_coinvolti = pmap(list(userid, original_tweet_userid), union)
  )

# Seleziona le righe che coinvolgono gli utenti originali o chi ha fatto il retweet
df <- df %>%
  filter(
    userid %in% utenti_coinvolti | original_tweet_userid %in% utenti_coinvolti
  )


# Partizionamento varie tipologie di tweet
valueSent <- df %>%
  group_by(userid, original_tweet_userid) %>%
  summarise(
    # Conteggi e medie per ciascun tipo di sentiment
    Negativi_n = sum(sentiment == "neg", na.rm = TRUE),
    Negativi_score = mean(score[sentiment == "neg"], na.rm = TRUE),
    
    Neutrali_n = sum(sentiment == "neu", na.rm = TRUE),
    Neutrali_score = mean(score[sentiment == "neu"], na.rm = TRUE),
    
    Positivi_n = sum(sentiment == "pos", na.rm = TRUE),
    Positivi_score = mean(score[sentiment == "pos"], na.rm = TRUE)
  )


dfPartizionati <- dataset %>%
  mutate(
    Tipo_Tweet = case_when(
      # Retweet
      is_retweet == TRUE ~ "Retweet",  # Cambia 'is_retweet' con 'is_retweeted'
      # Risposte
      in_reply_to_status_id != "                  0" & is_retweeted == FALSE ~ "Risposta",
      # Citazioni
      is_quote_status == TRUE & is_retweeted == FALSE & in_reply_to_status_id == "                  0" ~ "Citazione",
      # Tweet Normali
      TRUE ~ "Normale"
    ),
    
    # Identificazione del sentiment prevalente per l'interazione
    Sentiment_Interazione = case_when(
      Positivi_n > Negativi_n & Positivi_n > Neutrali_n ~ "pos",
      Negativi_n > Positivi_n & Negativi_n > Neutrali_n ~ "neg",
      TRUE ~ "neu" # Default neutrale se non c'è prevalenza
    )
  )

#percentuali delle tipologie di tweet
table(dfPartizionati$Tipo_Tweet)
```

```{r}

dfUtenti <- dfPartizionati2 %>%
  group_by(userid, username) %>%
  summarise(
    Totale_Tweet = n(),
    Totale_Retweet = sum(Tipo_Tweet == "Retweet"),
    Totale_Risposte = sum(Tipo_Tweet == "Risposta"),
    Totale_Citazioni = sum(Tipo_Tweet == "Citazione"),
    Totale_TweetNormali = sum(Tipo_Tweet == "Normale"),
    
    TweetNormali_Pos = sum(Tipo_Tweet == "Normale" & sentiment == "pos"),
    TweetNormali_Neu = sum(Tipo_Tweet == "Normale" & sentiment == "neu"),
    TweetNormali_Neg = sum(Tipo_Tweet == "Normale" & sentiment == "neg"),
    
    Retweet_Pos = sum(Tipo_Tweet == "Retweet" & sentiment == "pos"),
    Retweet_Neu = sum(Tipo_Tweet == "Retweet" & sentiment == "neu"),
    Retweet_Neg = sum(Tipo_Tweet == "Retweet" & sentiment == "neg"),
    
    Replay_Pos = sum(Tipo_Tweet == "Risposta" & sentiment == "pos"),
    Replay_Neu = sum(Tipo_Tweet == "Risposta" & sentiment == "neu"),
    Replay_Neg = sum(Tipo_Tweet == "Risposta" & sentiment == "neg"),
    
    Quotes_Pos = sum(Tipo_Tweet == "Citazione" & sentiment == "pos"),
    Quotes_Neu = sum(Tipo_Tweet == "Citazione" & sentiment == "neu"),
    Quotes_Neg = sum(Tipo_Tweet == "Citazione" & sentiment == "neg"),
    
    GlobalMean_Pos = mean(score[sentiment == "pos"], na.rm = TRUE),
    GlobalMean_Neu = mean(score[sentiment == "neu"], na.rm = TRUE),
    GlobalMean_Neg = mean(score[sentiment == "neg"], na.rm = TRUE),
    
    Mean_Pos_Norm = mean(score[Tipo_Tweet == "Normale" & sentiment == "pos"], na.rm = TRUE),
    Mean_Neu_Norm = mean(score[Tipo_Tweet == "Normale" & sentiment == "neu"], na.rm = TRUE),
    Mean_Neg_Norm = mean(score[Tipo_Tweet == "Normale" & sentiment == "neg"], na.rm = TRUE),
    
    Totale_Interazioni = Totale_Risposte + Totale_Citazioni,
    Media_Retweet = mean(retweetcount, na.rm = TRUE),
    Media_Like = mean(favorite_count, na.rm = TRUE),
    Totale_Retweet = sum(retweetcount, na.rm = TRUE),
    Totale_Like = sum(favorite_count, na.rm = TRUE),
    Followers_Min = min(followers, na.rm = TRUE),
    Followers_Max = max(followers, na.rm = TRUE),
    Rapporto_Follower_Following = mean(followers / following, na.rm = TRUE)
  ) %>%
  ungroup()

# Classificazione Utenti in base alle metriche per: Attività, Influenza e Possibile Sentiment
dfUtenti <- dfUtenti %>%
  mutate(
    # Metriche di Attività
    Interazioni_Totali = Totale_Retweet + Totale_Risposte + Totale_Citazioni,
    
    # Metriche di Influenza
    Engagement_Totale = Totale_Retweet + Totale_Like,
    Engagement_Relativo = Engagement_Totale / Followers_Max,
    Media_Retweet_Per_Tweet = Totale_Retweet / Totale_Tweet,
    Media_Like_Per_Tweet = Totale_Like / Totale_Tweet,
    
    # Classificazione per Attività
    Classe_Attivita = case_when(
      Totale_Tweet >= quantile(Totale_Tweet, 0.75) ~ "Alta",
      Totale_Tweet >= quantile(Totale_Tweet, 0.50) ~ "Moderata",
      TRUE ~ "Bassa"
    ),
    
    # Classificazione per Influenza
    Classe_Influenza = case_when(
      Engagement_Relativo >= quantile(Engagement_Relativo, 0.75, na.rm = TRUE) ~ "Alta",
      Engagement_Relativo >= quantile(Engagement_Relativo, 0.50, na.rm = TRUE) ~ "Moderata",
      TRUE ~ "Bassa"
    ),
    
    # Etichettatura basata su numero e score
    Etichetta = case_when(
      (Totale_TweetNormali>0 & 
        TweetNormali_Neg > TweetNormali_Neu & 
        TweetNormali_Neg > TweetNormali_Pos) & 
        Mean_Neg_Norm > 0.5 ~ "Potenziale Negativo",
      
      (Totale_TweetNormali>0 & 
        TweetNormali_Pos > TweetNormali_Neu & 
        TweetNormali_Pos > TweetNormali_Neg) & 
        Mean_Pos_Norm > 0.5 ~ "Potenziale Positivo",
      
      (Totale_TweetNormali>0 &
        TweetNormali_Neu > TweetNormali_Pos & 
        TweetNormali_Neu > TweetNormali_Neg) & 
        Mean_Neu_Norm > 0.5 ~ "Potenziale Neutrale",
      
      TRUE ~ "obs"
    )
  )


dfUtenti <- dfUtenti %>% mutate(
  userid = format(as.numeric(userid), 
                                    scientific = FALSE)
)

dfUtenti <- dfUtenti %>%
  distinct(userid, .keep_all = TRUE)
```

```{r}
retweet_relations <- dfPartizionati2 %>%
  filter(Tipo_Tweet == "Retweet") %>%
  distinct()  # Assicurati che ogni relazione di retweet sia unica

# Codice per creare il dataset delle relazioni:
dfRetweet <- retweet_relations %>%  
  summarise(
    # Conteggi e medie per ciascun tipo di sentiment
    Negativi_n = sum(sentiment == "neg", na.rm = TRUE),
    Negativi_score = mean(score[sentiment == "neg"], na.rm = TRUE),
    
    Neutrali_n = sum(sentiment == "neu", na.rm = TRUE),
    Neutrali_score = mean(score[sentiment == "neu"], na.rm = TRUE),
    
    Positivi_n = sum(sentiment == "pos", na.rm = TRUE),
    Positivi_score = mean(score[sentiment == "pos"], na.rm = TRUE)
  ) %>%
  ungroup() %>%
  mutate(
    # Identificazione del sentiment prevalente per l'interazione
    Sentiment_Interazione = case_when(
      Positivi_n > Negativi_n & Positivi_n > Neutrali_n ~ "pos",
      Negativi_n > Positivi_n & Negativi_n > Neutrali_n ~ "neg",
      TRUE ~ "neu" # Default neutrale se non c'è prevalenza
    )
  )
```

# Retweet Network Analysis

```{r}
# Creazione del grafo con igraph
G_retweet <- graph_from_data_frame(
  d = dfRetweet,          # Archi
  vertices = dfUtenti,      # Nodi
  directed = TRUE           # Grafo orientato
)

# Aggiunta di pesi e attributi al grafo
# E(grafo)$sentiment <- dfRelazioni$Sentiment_Interazione
# E(grafo)$positivi <- dfRelazioni$Positivi_n
# E(grafo)$negativi <- dfRelazioni$Negativi_n
# E(grafo)$neutrali <- dfRelazioni$Neutrali_n
# 
# V(grafo)$attivita <- dfUtenti$Classe_Attivita
# V(grafo)$influenza <- dfUtenti$Classe_Influenza
# V(grafo)$sentiment <- dfUtenti$Etichetta
```

```{r}
library(stringr)

# Filtraggio degli utenti perché altriemnti sono troppi
# Per influenza
dfUtenti2 <- dfUtenti %>% 
  filter(userid %in% dfRetweet$userid_origine | userid %in% dfRetweet$userid_target)

dfRetweet <- dfRetweet %>%
  mutate(across(c(userid_origine, userid_target), str_trim))

dfUtenti2 <- dfUtenti2 %>%
  mutate(userid = str_trim(userid))

dfInfluenti <- dfUtenti2 %>%
  filter(Etichetta %in% c("Potenziale Positivo", "Potenziale Negativo", "Potenziale Neutrale") & Classe_Influenza %in% c("Moderata", "Alta"))

dfRetweet2 <- dfRetweet %>%
  filter(userid_origine %in% dfInfluenti$userid & 
           (Negativi_score>0.8 | Positivi_score>0.8 | Neutrali_score>0.8))


extra_nodes <- tibble(userid = missing_nodes)
dfInfluenti <- bind_rows(dfInfluenti, extra_nodes)


dfInfluenti <- dfInfluenti %>%
  filter(Etichetta %in% c("Potenziale Positivo", "Potenziale Negativo", "Potenziale Neutrale") & Classe_Influenza %in% c("Moderata", "Alta"))
```

```{r}
# subset del grafo
G_retweet3 <- graph_from_data_frame(
  d = dfRetweet2,          # Archi
  vertices = dfInfluenti,      # Nodi
  directed = TRUE           # Grafo orientato
)

library(ggraph)
# Layout del grafo
ggraph(G_retweet2, layout = "fr") + # Forza di Fruchterman-Reingold
  geom_edge_link(aes(color = Sentiment_Interazione), arrow = arrow(type = "closed", length = unit(2, "mm")), alpha = 0.8) +
  geom_node_point(aes(size = Followers_Max, color = Etichetta)) +
  geom_node_text(aes(label = username), repel = TRUE, size = 3) +
  scale_edge_color_manual(values = c("pos" = "green", "neg" = "red", "neu" = "blue")) +
  scale_color_manual(values = c("Potenziale Positivo" = "darkgreen", "Potenziale Neutrale" = "darkblue", "Potenziale Negativo" = "darkred")) +
  theme_light()
```

```{r}
# Creazione di un grafo con igraph
G_retweet3 <- graph_from_data_frame(
  d = dfRelInf,          # Archi
  vertices = dfVertici,      # Nodi
  directed = FALSE           # Grafo orientato
)

# Layout del grafo
ggraph(G_retweet3, layout = "fr") + # Forza di Fruchterman-Reingold
  geom_edge_link(aes(color = Sentiment_Interazione), arrow = arrow(type = "closed", length = unit(2, "mm")), alpha = 0.8) +
  geom_node_point(aes(size = Followers_Max, color = Etichetta)) +
  geom_node_text(aes(label = username), repel = TRUE, size = 3) +
  scale_edge_color_manual(values = c("pos" = "green", "neg" = "red", "neu" = "blue")) +
  scale_color_manual(values = c("Potenziale Positivo" = "darkgreen", "Potenziale Neutrale" = "darkblue", "Potenziale Negativo" = "darkred", "obs"="grey80")) +
  theme_light()
```

```{r}
library(ggnetwork)

# Trasformazione del grafo in un oggetto compatibile con ggnetwork
grafo_network <- ggnetwork(G_retweet2, arrow.gap = 0.015)

# Visualizzazione del grafo
ggplot(grafo_network, aes(x = x, y = y, xend = xend, yend = yend)) + 
  # Archi con colore basato sul Sentiment_Interazione
  geom_edges(aes(color = Sentiment_Interazione), 
             arrow = arrow(length = unit(3.5, "pt"), type = "closed")) +
  # Nodi con dimensione e colore basati sui dati
  geom_nodes(aes(size = Followers_Max, color = Etichetta)) +
  # Palette per i colori degli archi
  scale_color_manual(
    values = c(
      "Potenziale Positivo" = "darkgreen", 
      "Potenziale Neutrale" = "darkblue", 
      "Potenziale Negativo" = "darkred",
      "obs" = "grey80"
    )
  ) +
  scale_edge_color_manual(
    values = c("green", "red", "blue")
  ) +
  # Tema minimale e dettagli grafici
  theme_blank()
```

```{r}
# Trasformazione del grafo in un oggetto compatibile con ggnetwork
grafo_net <- ggnetwork(grafo_Edge, arrow.gap = 0.015)

# Assicurati che Sentiment_Interazione sia un fattore con livelli corretti
grafo_net$Sentiment_Interazione <- as.factor(grafo_net$Sentiment_Interazione)

# Visualizzazione del grafo
ggplot(grafo_net, aes(x = x, y = y, xend = xend, yend = yend)) + 
  geom_nodes(aes(size = Followers_Max, color = Etichetta)) +
  geom_edges(aes(color = Sentiment_Interazione), 
             arrow = arrow(length = unit(3.5, "pt"), type = "closed")) +
  # Palette dei colori per gli archi basata sui livelli di Sentiment_Interazione
  scale_edge_color_manual(
    values = c("pos" = "green", "neg" = "red", "neu" = "blue")
  ) +
  # Palette dei colori per i nodi
  scale_color_manual(
    values = c(
      "Potenziale Positivo" = "darkgreen", 
      "Potenziale Neutrale" = "darkblue", 
      "Potenziale Negativo" = "darkred",
      "obs" = "grey80"
    )
  ) +
  theme_blank()
```

## Ipergrafi (?)

```{r}
# Raggruppare le relazioni con lo stesso tipo di sentiment e alta rilevanza
# Convertire i dati in una lista di iperarchi
hyper_relazioni <- dfRelazioni %>%
  filter(userid_origine %in% dfInfluenti$userid) %>%
  group_by(Sentiment_Interazione) %>%
  summarise(
    utenti_coinvolti = list(unique(c(userid_origine, userid_target)))
  )
```

```{r}
library(HyperG)
# Creare un ipergrafo dalla lista di archi
edges_list <- hyper_relazioni$utenti_coinvolti
hyper_grafo <- hypergraph_from_edgelist(edges_list)

# Visualizzare l'ipergrafo
plot(hyper_grafo, main = "Ipergrafo delle Relazioni Sentiment")
```

```{r}
library(igraph)
library(ggraph)
library(dplyr)

# Rimuovere i duplicati basati su userid
dfUtentiUniti <- dfUtentiUniti %>%
  distinct(userid, .keep_all = TRUE)


# Uniamo userid_origine e userid_target per ottenere tutti i nodi che appaiono nelle relazioni
nodi_relazioni <- unique(c(dfRelazioni$userid_origine, dfRelazioni$userid_target))

# Controlliamo quali nodi sono presenti in dfUtentiUniti
nodi_mancanti <- setdiff(nodi_relazioni, dfUtentiUniti$userid)

dfUtenti <- bind_rows(dfUtenti, nodi_mancanti)

# 2. Creazione della rete utilizzando dfRelazioni (Retweet)
g <- graph_from_data_frame(dfRelazioni, 
                           directed = TRUE, 
                           vertices = dfUtentiUniti)

# 4. Definisci i colori per i nodi (in base all'etichetta dell'utente)
node_colors <- c("Potenziale Negativo" = "red", 
                 "Potenziale Positivo" = "green", 
                 "Potenziale Neutrale" = "gray", 
                 "Non_Etichettati" = "lightgray")

# 5. Definisci i colori per gli archi (basato sul sentiment dei retweet)
edge_colors <- c("pos" = "green", "neg" = "red", "neu" = "gray")

# 6. Visualizzazione della rete con ggraph
ggraph(g, layout = 'fr') +
  # Nodo colorato in base al sentiment dell'utente
  geom_node_point(aes(color = sentiment), size = 5) +
  scale_color_manual(values = node_colors) +
  # Archi colorati in base al sentiment del retweet
  geom_edge_link(aes(color = sentiment), alpha = 0.8) +
  scale_edge_color_manual(values = edge_colors) +
  theme_void() +
  labs(title = "Rete di Retweet con Sentiment degli Utenti e Interazioni")
```

```{r}
# identifico i primi k utenti più influenti come gli outliers tra gli utenti che sono stati retwittati:
Q1 <- quantile(n_retweet$retweet_count, 0.25)
Q3 <- quantile(n_retweet$retweet_count, 0.75)
IQR <- Q3 - Q1

# soglia per gli outlier
threshold <- Q3 + 3 * IQR

# estraggo gli utenti più influenti
top_users <- n_retweet %>%
  filter(retweet_count > threshold)

top_users #313 utenti

summary(top_users$retweet_count) # ancora range molto grande

Q1 <- quantile(top_users$retweet_count, 0.25)
Q3 <- quantile(top_users$retweet_count, 0.75)
IQR <- Q3 - Q1

# soglia per gli outlier
threshold <- Q3 + 3 * IQR

# estraggo gli utenti più influenti
top_users2 <- top_users %>%
  filter(retweet_count > threshold)

top_users2 #23 utenti

summary(top_users2$retweet_count) #range buono
```

```{r}
# bisogna filtrare il dataset per considerare solo i retweet associati ai top utenti
filtered_data <- dataset %>%
  filter(is_retweet == 1 & original_tweet_userid %in% top_users2$original_tweet_userid)
```
